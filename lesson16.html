<!doctype HTML>
<html>
   <head>
      <link href="css/reset.css" rel="stylesheet" type="text/css">
      <link href="css/scafolding.css" rel="stylesheet" type="text/css">
      <link href="css/typography.css" rel="stylesheet" type="text/css">
      <link href="css/content.css" rel="stylesheet" type="text/css">
      <link href="css/table-of-contents.css" rel="stylesheet" type="text/css">
      <link href="css/sidebar.css" rel="stylesheet" type="text/css">
      <link href="css/footer.css" rel="stylesheet" type="text/css">
      <link href="css/navigation.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet"
      href="js/third-party/highlight.dark.css">
    <script src="js/third-party/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

   </head>

   <body>
      <div id="page">
		  <nav id="nav" data-active="lessen"></nav>
		  <div id="content">
		  
  			 <section class="show_lessons">
			</section>

			 <section>
 			 <iframe width="560" height="315" src="https://www.youtube.com/embed/tkfBK3E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

			 <h1>Les 16</h1>
			 <h3>Het maken van games</h3>
		  <h2>Is SVG geschikt voor het maken van (2D) games?</h2>
			<p>SVG is een erg goeie basis engine voor 2D games en complexe interactiviteit.
        Het ondersteund tegenwoordig, out of the box animatie, fonts, grouping, intelligent reuse, filters en basis interactiviteit voor klikken en hoveren,
    maar we missen nog een paar dingen die erg interessant zijn voor 2D game-development.
			</p>
      <ul>
        <li>Het volgen van paden</li>
        <li>Point In Polygon ondersteuning voor complexe hittesten</li>
        <li>Global to Local en Local to Global coordinaat ondersteuning voor intelligen grouperen en degrouperen.</li>
      </ul>
      <div class="full-column">
        Gelukkig is er <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement">SVGGeometryElement</a>.
        Behalve Firefox en natuurlijk Edge ondersteunt verder iedere browser dit nu ook out of the box.
        Dit komt voornamelijk, omdat veel functionaliteit voor dit element recentelijk verplaatst is van <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGPathElement/getPointAtLength">SVGPathElement</a> naar SVGGeometryElement.
        Dat is vervelend, maar betekent ook, dat we kans op een fallback hebben voor browsers die het NIET ondersteunen.
      </div>
			 </section>
			 <style>
			   .example{
			     border: 1px solid #ff0;
			   }
			   .example svg{
			     border: 1px solid #888;
			     width: 100%;
			   }
			   .example textarea{
			     width: 100%;
			     height: 300px;
			     overflow-y: scroll;
			     border: 1px solid #888;
			   }
			 </style>
			 <section>
				<h2>Belangrijke functionaliteit</h2>
				  

  				<h2>getPointAtLength, pathLength, getTotalLength</h2>
          <p>Vijanden in een game zitten vaak op een path, als je dit wilt mengen met physics en ook als het path wat complexer wordt, is het
          handig hier wat ondersteuning bij te hebben. Ook bij complexe animaties, waarbij je de ene vorm in de andere "morpht" is het handig om
          een willekeurig punt op een path the kunnen bepalen, zo kun je een vorm tijdelijk "flattenen" en de resulterende polyline is dan makkelijk te morphen ( je kunt ook snap.js gebruiken, natuurlijk, maar da's 80Kb aan je pagina toevoegen).</p>
          <div class="example" id="folow-path-example">
<svg id="follow_path" width="400">
  <path id="follow" d="M10 10 L 100 100 C 150 150 400 200 390 0" stroke="#000" fill="none"></path>
  <circle id="follower" r="5" fill="red"></circle>
</svg>
              <script>
(function(){
  var enemy={dom: document.getElementById("follower"),x:0,y:0,dx:0,dy:0};
  var path=document.getElementById("follow");
  var time=0;
  
  animate()
  function animate()
  {
  	time++;
    var total_length=path.getTotalLength();
    var place_on_path=time%total_length;
    var p=path.getPointAtLength(place_on_path);
    enemy.x+=enemy.dx;
    enemy.y+=enemy.dy;
    if(time%100==0)
    {
      var random_color="rgb("+Math.floor(Math.random()*255)+","+Math.floor(Math.random()*255)+","+Math.floor(Math.random()*255)+")";
      enemy.dom.setAttribute("fill",random_color);
      enemy.dy=-20;
    }
    enemy.dx*=0.9;
    enemy.dy*=0.9;
    
    enemy.x=enemy.x*0.9+0.1*p.x;
    enemy.y=enemy.y*0.9+0.1*p.y;
    enemy.dom.setAttribute("cx",enemy.x);
    enemy.dom.setAttribute("cy",enemy.y);
  	window.requestAnimationFrame(animate);
}

})();</script>
              <pre><code class="svg" contenteditable="true"></code></pre>
              <pre><code class="javascript" contenteditable="true"></code></pre>
            </div>
            <p>Omdat het soms lastig is te werken met de berekende getTotalPathLength (bijvoorbeeld bij responsive SVGÂ´s)
            Kun je ook in SVG een pathlenght zetten.<code><path d="M 0,20 h100" pathLength="90"/></code></p>

  				<h2>createSVGPoint(), isPointInFill(), isPointInStroke()</h2>
  				<p>Stel je voor dat je een race game maakt. Als de auto OP de weg is, kan hij sneller.
  				De weg is een grillige vorm. Dan heb je wat we in de business noemen een PIP(Point in polygon) of hitTest nodig.
  				Een makkelijke manier om te testen of een punt in een vorm zit.</p>
  				<div class="example" id="hero_weg_example">
      				<svg id="svg" width="100%" viewbox="0 0 400 200"  height="200" preserveAspectRatio="xMidYMid meet">
                <path id="weg" d="M 20 20 Q 200 0 280 20 Q 370 100 180 180 L 120 180 z" fill="none" stroke="#888" stroke-width="30"></path>
                <path id="weg" d="M 20 20 Q 200 0 280 20 Q 370 100 180 180 L 120 180 z" fill="none" stroke="#fff" stroke-dasharray="15,15"></path>
                <circle id="hero" cx="100" cy="100" r="5" fill="#000"></circle>
              </svg>
              <script>
              (function(){
                var interactive_example = document.getElementById("hero_weg_example");
                var svg=interactive_example.getElementsByTagName("svg")[0];
                var weg=document.getElementById("weg");
                var hero={};
                hero.dom=document.getElementById("hero");
                hero.x=100;
                hero.y=100;
                hero.dx=1; /* direction of travel */
                hero.dy=1;
  
                animate();
                function animate()
                {
                   var testpoint=svg.createSVGPoint();
                   testpoint.x=hero.x;
                   testpoint.y=hero.y;
                  if(weg.isPointInStroke(testpoint))
                  {
                  	hero.speed=3;
                  }else
                  {
                  	hero.speed=1;
                  }
                	hero.x+=hero.dx*hero.speed;
                	hero.y+=hero.dy*hero.speed;
                  if(hero.x<0) hero.dx=Math.abs(hero.dx);
                  if(hero.y<0) hero.dy=Math.abs(hero.dy);
                  if(hero.x>400) hero.dx=-Math.abs(hero.dx);
                  if(hero.y>200) hero.dy=-Math.abs(hero.dy);
                  hero.dom.setAttribute("cx",hero.x);
                  hero.dom.setAttribute("cy",hero.y);
                  window.requestAnimationFrame(animate);
                }
              })();
              </script>
              <pre><code class="svg" contenteditable="true"></code></pre>
              <pre><code class="javascript" contenteditable="true"></code></pre>
            </div>
            <p>Om isPointinStroke of isPointInFill te kunnen gebruiken, moet je een punt meegeven, dit is een <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGPoint">SVGPoint</a></p>. Deze maak je met SVG.createSVGPoint() <code>var point = document.getElementById("SVG-ElementID").createSVGPoint();</code>. Vervolgens kun je de x en y van dit punt zetten.
			 </section>

			 <section>
				<h2>OPDRACHT</h2>
			 </section>
			 <section class="show_lessons">
			</section>
			<script src="js/lessons.js" type="text/javascript"></script>
		  
		  </div>
	  </div>
<script>
	    var examples=document.getElementsByClassName("example");
	    for(var e=0;e<examples.length;e++)
	    {
          // copy stuff with highlighter script
          var interactive_example=examples[e];
    	    console.log("example found: "+interactive_example);
          var svg_code=interactive_example.getElementsByClassName("svg")[0];
          var js_code=interactive_example.getElementsByClassName("javascript")[0];
          var svg=interactive_example.getElementsByTagName("svg")[0].outerHTML;
          var js=interactive_example.getElementsByTagName("script")[0].innerHTML;
          js=js.split("(function(){").join("");
          js=js.split("})();").join("");
          svg_code.innerText=svg;
          js_code.innerText=js
                

          hljs.highlightBlock(svg_code);
          hljs.highlightBlock(js_code);
	    }
	    </script>
              <style>
                pre{
                  background-color: #333;
                  color: #fff;
                  font-size: 10px;
                  line-height: 10px;
                  width: 100%;
                  max-height: 200px;
                  overflow: scroll;
                }
              </style>

      <script src="js/navigation.js" type="text/javascript"></script>
   </body>
</html>